'''
# [Gold V] 소셜 네트워킹 어플리케이션 - 7511

[문제 링크](https://www.acmicpc.net/problem/7511)

### 성능 요약

메모리: 116668 KB, 시간: 384 ms

### 분류

그래프 이론, 자료 구조, 분리 집합

### 제출 일자

2025년 9월 24일 15:44:13

### 문제 설명

<p>어렸을때부터 컴퓨터 프로그래밍에 엄청난 소질을 보인 상근이는 항상 소셜 네트워킹 웹사이트를 만들고 싶어 했다. 상근이는 페이스북을 벤치마킹하기 위해 지난 3년간 열심히 사용을 했고, 이제 페이스북의 단점을 보완한 새 소셜 네트워킹 웹 2.0 어플리케이션을 만들려고 한다.</p>

<p>사람들은 소셜 네트워킹 어플리케이션에 가입을 한 다음, 현실에서 아는 사람을 친구로 추가하기 시작한다. 이러한 친구 관계 정보를 이용해 친구 관계 그래프를 그릴 수 있다.</p>

<p>소셜 네트워킹 어플리케이션에서 가장 중요한 기능은 한 사람이 다른 사람의 페이지를 방문했을 때, 친구 관계 그래프에서 두 사람 사이의 경로를 보여주는 기능이다. 경로가 없는 경우에는 보여주지 않는다.</p>

<p>상근이의 서비스는 매우 유명해졌고, 위의 기능은 사람들이 점점 많아질수록 경로를 구하는 시간이 매우 느려지게 되었다. 그 이유는 두 사람 사이의 경로가 없는 경우에 경로를 찾기 위해 너무 오랜시간 그래프를 탐색하기 때문이었다. 따라서, 상근이는 두 사람 사이의 경로가 존재하는지 안 하는지를 미리 구해보려고 한다.</p>

<p>유저의 수와 각 유저의 친구 관계가 입력으로 주어진다. 이때, 주어지는 두 사람이 친구 관계 그래프상에서 경로가 존재하는지 안 하는지를 구하는 프로그램을 작성하시오.</p>

### 입력

 <p>입력은 여러 개의 테스트 케이스로 이루어져 있다.</p>

<p>각 테스트 케이스의 첫째 줄에는 유저의 수 1 ≤ n ≤ 10<sup>6</sup>이 주어진다. 둘째 줄에는 친구 관계의 수 1 ≤ k ≤ 10<sup>5</sup>가 주어진다. 다음 k개 줄에는 두 정수 0 ≤ a, b < n이 주어진다. 두 수는 친구 관계를 나타내며, 유저 a와 b가 친구라는 소리이다. 다음 줄에는 미리 구할 쌍의 수 1 ≤ m ≤ 10<sup>5</sup>가 주어진다. 다음 m개 줄에는 구해야하는 쌍을 나타내는 u, v가 주어진다.</p>

### 출력

 <p>각 테스트 케이스마다 "Scenario i:"를 출력한다. i는 테스트 케이스 번호이며, 1부터 시작한다. 그 다음, 각각의 쌍마다 두 사람을 연결하는 경로가 있으면 1, 없으면 0을 출력한다.</p>

<p>각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.</p>

'''


'''
## 결론

1. n의 최댓값이 10^6이기에 recursion limit을 10^6으로 설정
-> 메모리 초과
2. 1000으로 변경
-> 통과
-> 통과의 이유

    sys.setrecursionlimit(1000)은 Union-Find의 find_set (경로 압축 적용 시)의 **실제 재귀 깊이(약 5~6회)**를 커버하고도 남을 만큼 충분히 큰 값입니다.
    1000보다 더 작은 값, 예를 들어 100이나 50으로 제한해도 이론적으로는 Union-Find는 문제없이 작동할 것입니다.

    하지만 log1000 (약 3)으로 설정하는 것은 정확하지 않으며, 불필요하게 기본값보다 더 제한을 두는 것이므로 권장되지 않습니다. log* N은 로그함수가 아니기 때문에 log_b(N)과 같은 일반적인 로그값으로 생각하면 안 됩니다.

    가장 실용적인 방법:
    Union-Find처럼 재귀 깊이가 매우 얕다는 것을 확실히 아는 경우: sys.setrecursionlimit()을 따로 설정하지 않거나, 파이썬의 기본값(1000)을 그대로 사용해도 충분합니다.
    재귀 깊이가 N에 비례할 수 있는 일반적인 DFS/재귀 문제: N의 최대치에 맞게 sys.setrecursionlimit(N의 최댓값 + 여유분)으로 설정하되, 너무 큰 값으로 인해 메모리 초과가 발생한다면, 반복문(while)으로 재귀를 stack을 이용한 형태로 바꾸는 것이 더 안전합니다.
'''

import sys
sys.setrecursionlimit(1000)
input = lambda : sys.stdin.readline().rstrip()

def find_set(x) :
    # 만약 내가 대표자면 나 출력
    if parents[x] == x :
        return x

    parents[x] = find_set(parents[x])
    return parents[x]

def union_set(x, y) :
    px = find_set(x)
    py = find_set(y)

    # 둘이 친구인지 확인
    if px == py :
        return
    elif px < py :
        parents[py] = px
    else :
        parents[px] = py


T = int(input())
for t in range(1, T+1) :
    n = int(input()) # 유저의 수
    k = int(input()) # 친구 관계의 수

    # Todo: 나를 대표자로 설정하는 parents 만들기
    parents = [i for i in range(n)]

    for _ in range(k) :
        a, b = map(int, input().split())

        # 친구가 아니면 친구로 연결
        union_set(a, b)

    print(f"Scenario {t}:")
    m = int(input())  # 구할 쌍의 개수
    for _ in range(m) :
        c, d = map(int, input().split())
        # 친구인지 확인, 친구면 1, 아니면 0 출력
        if find_set(c) == find_set(d) :
            print(1)
        else :
            print(0)

    # 각 테스트 케이스 사이에 빈 줄 출력
    if t < T:
        print()