"""
BOJ14503. 로봇 청소기

[문제]

로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.
로봇 청소기가 있는 방은 N * M 크기의 직사각형으로 나타낼 수 있으며, 1 * 1 크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 방의 각 칸은 좌표 (r, c)로 나타낼 수 있고, 가장 북쪽 줄의 가장 서쪽 칸의 좌표가 (0, 0), 가장 남쪽 줄의 가장 동쪽 칸의 좌표가 (N-1, M-1)이다. 즉, 좌표 (r, c)는 북쪽에서 (r+1)$번째에 있는 줄의 서쪽에서 (c+1)번째 칸을 가리킨다. 처음에 빈 칸은 전부 청소되지 않은 상태이다.
로봇 청소기는 다음과 같이 작동한다.

1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.

2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우,
    1) 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.
    2) 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.

3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우,
    1) 반시계 방향으로 90도 회전한다.
    2) 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.
    3) 1번으로 돌아간다.

[입력]
첫째 줄에 방의 크기 N과 M이 입력된다.(3 <= N, M <= 50)

둘째 줄에 처음에 로봇 청소기가 있는 칸의 좌표(r, c)와 처음에 로봇 청소기가 바라보는 방향 d가 입력된다.
d가 0인 경우 북쪽, 1인 경우 동쪽, 2인 경우 남쪽, 3인 경우 서쪽을 바라보고 있는 것이다.

셋째 줄부터 N개의 줄에 각 장소의 상태를 나타내 N * M개의 값이 한 줄 M개씩 입력된다.
i번째 줄의 j번째 값은 칸 (i, j)의 상태를 나타내며, 이 값이 0인 경우 (i, j)가 청소되지 않은 빈 칸이고, 1인 경우 (i, j)에 벽이 있는 것이다.
방의 가장 북쪽, 가장 남쪽, 가장 서쪽, 가장 동쪽 줄 중 하나 이상에 위치한 모든 칸에는 벽이 있다. 로봇 청소기가 있는 칸은 항상 빈 칸이다.

[출력]
로봇 청소기가 작동을 시작한 후 작동을 멈출 때까지 청소하는 칸의 개수를 출력한다.
"""

import sys
input = lambda: sys.stdin.readline().rstrip()

# 북동남서 델타 배열 (0: 북쪽, 1: 동쪽, 2: 남쪽, 3: 서쪽)
dy = [-1, 0, 1, 0]
dx = [0, 1, 0, -1]

def run_robot_vacuum(sy, sx, sd):   # 로봇 청소기를 이용해 청소 시뮬레이션을 진행하여 청소하는 칸의 개수를 구하는 함수

    cnt = 0 # cnt: 청소한 칸의 개수를 0으로 초기화
    cur_y, cur_x, cur_d = sy, sx, sd    # 현재 좌표와 방향을 시작 좌표와 시작 방향으로 설정

    while True: # 로봇 청소기가 멈출 때까지 가동
        
        if not cleaned[cur_y][cur_x] and room[cur_y][cur_x] == 0:   # 작동 조건 1: 현재 칸이 청소되지 않은 경우,
            cleaned[cur_y][cur_x] = True    # 현재 칸을 청소
            cnt += 1    # 청소한 칸의 개수를 count

        # 작동 조건 2: 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있으면 이동
        moved = False    # 아직 주변 4칸 검사가 완료되지 않아 움직이지 않음
        for _ in range(4):  # 4번 동안
            cur_d = (cur_d + 3) % 4 # 반시계 방향으로 회전
            ny, nx = cur_y + dy[cur_d], cur_x + dx[cur_d]   # 다음 칸은 현재 칸으로부터 회전한 방향으로 하나 앞 칸
            if 0<=ny<N and 0<=nx<M and not cleaned[ny][nx] and room[ny][nx] == 0:   # 다음 칸이 범위 내부에 있고, 청소되지 않은 빈 칸인 경우,
                cur_y, cur_x = ny, nx   # 그 방향으로 한 칸 전진
                moved = True    # 주변 4칸 중 빈 칸을 발견하여 전진했음을 moved에 표시
                break   # 주변 4칸 검사 종료

        if moved:   # 만약 빈 칸을 발견해 전진했다면,
            continue    # 작동 조건 1번으로 돌아감

        # 여전히 전진하지 못했다면, 작동 조건 3: 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없음
        bd = (cur_d + 2) % 4    # bd : 현재 바라보는 방향의 뒤쪽 방향
        by, bx = cur_y + dy[bd], cur_x + dx[bd] #(by, bx): 뒤쪽 방향 칸의 좌표
        if 0<=by<N and 0<=bx<M and room[by][bx] == 0:   # 뒤쪽 방향 칸이 범위 내부에 있고, 이동 가능한 빈 칸이면
            cur_y, cur_x = by, bx   # 바라보는 방향을 유지한 채로 뒤로 후진
            continue    # 작동 조건 1번으로 돌아감
        elif not (0<=by<N and 0<=bx<M) or room[by][bx] == 1:    # 만약 뒤쪽 방향 칸이 범위 밖이거나 벽이라서 후진 불가능하다면,
            break   # 작동 중지
            
    return cnt  # 지금까지 청소한 칸의 개수 반환

# main
N, M = map(int, input().split())    # N: 방의 세로 방향 크기, M: 방의 가로 방향 크기
sr, sc, sd = map(int, input().split())  # (sr, sc): 로봇 청소기가 있는 칸의 좌표, sd: 처음 로봇 청소기가 바라보는 방향
room = [list(map(int, input().split())) for _ in range(N)]  # 방의 각 셀의 상태 입력 받기
cleaned = [[False] * M for _ in range(N)]   # 로봇청소기의 청소 여부를 저장
cnt_cleaned = run_robot_vacuum(sr, sc, sd)  # 로봇 청소기를 이용한 청소 시뮬레이션을 진행해 청소한 칸의 개수를 cnt_cleaned에 저장
print(cnt_cleaned)  # 결과 출력
