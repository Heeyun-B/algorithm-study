"""
BOJ7511. 소셜 네트워킹 어플리케이션

[문제]
어렸을때부터 컴퓨터 프로그래밍에 엄청난 소질을 보인 상근이는 항상 소셜 네트워킹 웹사이트를 만들고 싶어 했다.
상근이는 페이스북을 벤치마킹하기 위해 지난 3년간 열심히 사용을 했고, 이제 페이스북의 단점을 보완한 새 소셜 네트워킹 웹 2.0 어플리케이션을 만들려고 한다.
사람들은 소셜 네트워킹 어플리케이션에 가입을 한 다음, 현실에서 아는 사람을 친구로 추가하기 시작한다.
이러한 친구 관계 정보를 이용해 친구 관계 그래프를 그릴 수 있다.
소셜 네트워킹 어플리케이션에서 가장 중요한 기능은 한 사람이 다른 사람의 페이지를 방문했을 때, 친구 관계 그래프에서 두 사람 사이의 경로를 보여주는 기능이다. 경로가 없는 경우에는 보여주지 않는다.
상근이의 서비스는 매우 유명해졌고, 위의 기능은 사람들이 점점 많아질수록 경로를 구하는 시간이 매우 느려지게 되었다.
그 이유는 두 사람 사이의 경로가 없는 경우에 경로를 찾기 위해 너무 오랜시간 그래프를 탐색하기 때문이었다.
따라서, 상근이는 두 사람 사이의 경로가 존재하는지 안 하는지를 미리 구해보려고 한다.
유저의 수와 각 유저의 친구 관계가 입력으로 주어진다. 이때, 주어지는 두 사람이 친구 관계 그래프상에서 경로가 존재하는지 안 하는지를 구하는 프로그램을 작성하시오.

[입력]
입력은 여러 개의 테스트 케이스로 이루어져 있다.
각 테스트 케이스의 첫째 줄에는 유저의 수 1 ≤ n ≤ 106이 주어진다.
둘째 줄에는 친구 관계의 수 1 ≤ k ≤ 105가 주어진다.
다음 k개 줄에는 두 정수 0 ≤ a, b < n이 주어진다. 두 수는 친구 관계를 나타내며, 유저 a와 b가 친구라는 소리이다.
다음 줄에는 미리 구할 쌍의 수 1 ≤ m ≤ 105가 주어진다.
다음 m개 줄에는 구해야하는 쌍을 나타내는 u, v가 주어진다.

[출력]
각 테스트 케이스마다 "Scenario i:"를 출력한다. i는 테스트 케이스 번호이며, 1부터 시작한다.
그 다음, 각각의 쌍마다 두 사람을 연결하는 경로가 있으면 1, 없으면 0을 출력한다.
각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.
"""

import sys
input = lambda: sys.stdin.readline().rstrip()

# n명의 유저를 각각 자신을 부모로 하는 독립적인 집합으로 초기화
def make_set(n):
    return [i for i in range(n + 1)]

# 특정 원소 x가 속한 집합의 대표를 찾는 함수
# 경로 압축(path compression)을 적용하여 탐색 속도를 최적화
def find_set(x):
    if x == parents[x]:
        return x
    parents[x] = find_set(parents[x])  # 부모를 최상위 대표로 갱신(경로 압축)
    return parents[x]

# 두 원소 x, y가 속한 집합을 합치는 함수
def union(x, y):
    rx = find_set(x)  # x의 대표
    ry = find_set(y)  # y의 대표

    # 이미 같은 집합이면 아무 것도 하지 않음
    if rx == ry:
        return
    # 두 집합이 다른 집합이면 숫자가 작은 쪽을 대표로 설정
    elif rx < ry:
        parents[ry] = rx
    else:
        parents[rx] = ry

# main
T = int(input())  # 테스트 케이스 개수
for tc in range(1, T + 1):
    n = int(input())  # 유저 수
    parents = make_set(n)  # 유저별로 독립 집합 생성

    k = int(input())  # 친구 관계 수
    for _ in range(k):
        a, b = map(int, input().split())
        union(a, b)  # 친구 관계가 있으면 두 유저를 같은 집합으로 합침

    m = int(input())  # 경로 존재 여부를 확인할 쌍의 개수
    print(f'Scenario {tc}:')
    for _ in range(m):
        u, v = map(int, input().split())
        # 두 유저의 대표가 같으면 같은 네트워크이므로 경로 존재 → 1, 다르면 다른 네트워크이므로 경로 없음 → 0
        print(1 if find_set(u) == find_set(v) else 0)
    print()  # 테스트 케이스 사이에 빈 줄 출력
