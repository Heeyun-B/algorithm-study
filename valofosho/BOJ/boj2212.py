"""
BOJ2212 - 센서
문제
한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.

각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.

입력
첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.

출력
첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.


문제 정의
1. N개의 센서, K개의 집중국 수가 주어진다
2. 센서가 설치된 위치가 한 줄에 주어진다.
3. 모든 센서에 닿을 수 있도록 K개의 집중국을 설치할 수 있는 방법

로직 정의
[1]
1. 이전에 풀어봤던 공유기 설치 문제랑 비슷한 느낌
-> 단순하게 그리디로 접근하기 보다는 어떠한 범위를 주어졌을 때
-> 이걸로 설치하는 개수가 K가 될 수 있는가
-> 차이점은 실제 개수만을 확인하는게 아니라 d가 가변이고 sum(d)가 최소가 되어야 한다는 점

[2]
1. 첫 센서는 반드시 첫 집중국의 범위의 시작점이 된다
-> 첫 집중국이 가져갈 수 있는 범위는 arr[:n-k]
* 같은 지점에 위치한 센서는 동일한 집중국의 서비스를 받으므로 set(list)로 중복 값을 제거한다.
2. i번째 집중국은 arr[앞에서의 선택지 + 1 :N-(K-i)] 만큼의 선택지만을 갖는다
3. 

[3]
1. K개의 집중국을 세운다 -> K-1개의 파티션을 세울 공간이 필요하다
2. arr 에서 각 인접값 끼리의 간격을 비교한 리스트를 새로 만들어준다
3. 해당 인접에서 K-1개만 최대값으로 없애고(어차피 파티션이니까)
4. 남은 간격들을 더해주면 센서의 최대 범위(최소) 가 만들어진다.


"""

import sys
input = sys.stdin.readline

N = int(input())
K = int(input())
arr = list(map(int, input().split()))
arr.sort()
gap = []
# 인접한 지역간의 간격 리스트 구하기
for i in range(N-1):
    gap.append(arr[i+1]-arr[i])
# 간격을 sort
gap.sort()
if gap:
    # K개의 값을 제외한 뒤 sum
    print(sum(gap[:N-K]))
else: # N = K 인 경우 즉, 각 집중국이 하나의 센서만을 담당하면 0
    print(0)